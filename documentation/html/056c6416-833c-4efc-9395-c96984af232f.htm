<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Atomicity and Ordering Guarantees.</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="056c6416-833c-4efc-9395-c96984af232f" /><meta name="Description" content="A discussion of the different guarantees and degrees of atomicity offered by different methods in Ariadne’s classes." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../styles/Presentation.css" /><link rel="stylesheet" type="text/css" href="ms-help://Hx/HxRuntime/HxLink.css" /><script type="text/javascript" src="../scripts/EventUtilities.js"> </script><script type="text/javascript" src="../scripts/SplitScreen.js"> </script><script type="text/javascript" src="../scripts/Dropdown.js"> </script><script type="text/javascript" src="../scripts/script_manifold.js"> </script><script type="text/javascript" src="../scripts/script_feedBack.js"> </script><script type="text/javascript" src="../scripts/CheckboxMenu.js"> </script><script type="text/javascript" src="../scripts/CommonUtilities.js"> </script><xml><MSHelp:Keyword Index="A" Term="056c6416-833c-4efc-9395-c96984af232f" /><MSHelp:Attr Name="RevisionNumber" Value="1" /><MSHelp:Attr Name="AssetID" Value="056c6416-833c-4efc-9395-c96984af232f" /><MSHelp:Attr Name="Abstract" Value="A discussion of the different guarantees and degrees of atomicity offered by different methods in Ariadne’s classes." /><MSHelp:Attr Name="TopicType" Value="kbArticle" /><MSHelp:Attr Name="Locale" Value="en-us" /></xml></head><body><input type="hidden" id="userDataCache" class="userDataStyle" /><input type="hidden" id="hiddenScrollOffset" /><img id="collapseImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" alt="Collapse image" title="Collapse image" /><img id="expandImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" alt="Expand Image" title="Expand Image" /><img id="collapseAllImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" /><img id="expandAllImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" /><img id="dropDownImage" style="display:none; height:0; width:0;" src="../icons/dropdown.gif" /><img id="dropDownHoverImage" style="display:none; height:0; width:0;" src="../icons/dropdownHover.gif" /><img id="copyImage" style="display:none; height:0; width:0;" src="../icons/copycode.gif" alt="Copy image" title="Copy image" /><img id="copyHoverImage" style="display:none; height:0; width:0;" src="../icons/copycodeHighlight.gif" alt="CopyHover image" title="CopyHover image" /><div id="header"><table id="topTable" cellspacing="0" cellpadding="0"><tr><td><span onclick="ExpandCollapseAll(toggleAllImage)" style="cursor:default;" onkeypress="ExpandCollapseAll_CheckKey(toggleAllImage, event)" tabindex="0"><img ID="toggleAllImage" class="toggleAll" src="../icons/collapse_all.gif" /> <label id="collapseAllLabel" for="toggleAllImage" style="display: none;">Collapse All</label><label id="expandAllLabel" for="toggleAllImage" style="display: none;">Expand All</label> </span><span>    </span><span id="devlangsDropdown" class="filter" tabindex="0"><img id="devlangsDropdownImage" src="../icons/dropdown.gif" /> <label id="devlangsMenuAllLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: All </nobr></label><label id="devlangsMenuMultipleLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Multiple </nobr></label><label id="devlangsMenuCSharpLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: C# </nobr></label><label id="devlangsMenuVisualBasicLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual Basic </nobr></label><label id="devlangsMenuManagedCPlusPlusLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual C++ </nobr></label><label id="devlangsMenuFSharpLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: F# </nobr></label></span></td></tr></table><div id="devlangsMenu"><input id="CSharpCheckbox" type="checkbox" data="CSharp,cs,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="CSharpCheckbox">C#</label><br /><input id="VisualBasicCheckbox" type="checkbox" data="VisualBasic,vb,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="VisualBasicCheckbox">Visual Basic</label><br /><input id="ManagedCPlusPlusCheckbox" type="checkbox" data="ManagedCPlusPlus,cpp,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="ManagedCPlusPlusCheckbox">Visual C++</label><br /><input id="FSharpCheckbox" type="checkbox" data="FSharp,fs,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="FSharpCheckbox">F#</label><br /></div><table id="bottomTable" cellpadding="0" cellspacing="0"><tr id="headerTableRow1"><td align="left"><span id="runningHeaderText">Ariadne</span></td></tr><tr id="headerTableRow2"><td align="left"><span id="nsrTitle">Atomicity and Ordering Guarantees.</span></td></tr><tr id="headerTableRow3"><td align="left"><span id="headfeedbackarea" class="feedbackhead"><a href="javascript:SubmitFeedback('jon@hackcraft.net','Ariadne','','1.0.0.0','','%0\dYour%20feedback%20is%20used%20to%20improve%20the%20documentation%20and%20the%20product.%20Your%20e-mail%20address%20will%20not%20be%20used%20for%20any%20other%20purpose%20and%20is%20disposed%20of%20after%20the%20issue%20you%20report%20is%20resolved.%20%20While%20working%20to%20resolve%20the%20issue%20that%20you%20report,%20you%20may%20be%20contacted%20via%20e-mail%20to%20get%20further%20details%20or%20clarification%20on%20the%20feedback%20you%20sent.%20After%20the%20issue%20you%20report%20has%20been%20addressed,%20you%20may%20receive%20an%20e-mail%20to%20let%20you%20know%20that%20your%20feedback%20has%20been%20addressed.%0\A%0\d','Customer%20Feedback');">Send Feedback</a></span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()" /><span style="color: DarkGray"><p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[This is preliminary documentation and is subject to change.]</p></span><div class="summary"><p>
                A discussion of the different guarantees and degrees of atomicity offered by different methods in
                <b>Ariadne</b>’s classes.
            </p></div><div class="introduction"><p>
                When defining collections intended for multi-threaded use, it is important to note just what guarantees are offered by
                the collection.
            </p></div><div id="sectionSectionID0EAAAA" class="seeAlsoNoToggleSection"><p>
                    With single-threaded use, we can (almost) always depend upon operations taking place in the order in which they
                    were performed. Hence, the first item dequeued from a queue will be the first enqueued to it, the first popped from
                    a stack the last pushed to it, and if two values are written to the same key in a dictionary, the second will be
                    the value that is later seen when querying the dictionary.
                </p><p>
                    With multi-threaded use, it becomes less clear which operation can be considered to have happened first, if indeed
                    either can; operations can be concurrently operating on separate cores, or a context-switch can mean that even if
                    two operations will take the same length of time, the second started may complete before he first.
                </p><p>
                    It can be worth considering the case of a properly-aligned, shared 32-bit integer that is being written-to and
                    read-from by several threads:
                </p><ol><li><p>
                            Without locking, the atomicity .NET offers with 32-bit values means that these reads and writes will all
                            succeed fully, but may be performed on the basis of stale information. For this reason operations like
                            <span class="code">x++</span> can produce inconsistent results – it reads in a value, increments it, and
                            then writes to a value that has since been changed by another thread. Further, there may be periods where
                            different cores are seeing different values for the same memory location. There remain times when the
                            degree of thread-safety provided by the atomicity of reads and writes suffices.
                        </p></li><li><p>
                            With the methods offered by the <span sdata="cer" target="T:System.Threading.Interlocked"><a href="http://msdn2.microsoft.com/en-us/library/5kczs5b5" target="_top">Interlocked</a></span>
                            class, operations can depend reliably upon the current value, or else are guaranteed to either succeed or
                            fail atomically, and report upon this success or failure.
                        </p></li><li><p>
                            With locking, synchronisation occurs according to the policy by which the developer uses the locks.
                        </p></li></ol><p>
                    Lock-free collections offer the first or the first two degrees of thread-safety to more complicated
                    data-structures.
                </p><p>
                    The first is not offered by many data-structures by default. Multiple threads acting upon the same collection can
                    put that collection into an inconsistent state, resulting in incorrect results (e.g.
                    <span sdata="cer" target="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)"><a href="http://msdn2.microsoft.com/en-us/library/htszx2dy" target="_top">ContainsKey</a></span>
                    may return <span class="code">false</span> for a key that was added to a dictionary and not subsequently removed) or
                    surprising errors (e.g. an <span sdata="cer" target="T:System.IndexOutOfRangeException"><a href="http://msdn2.microsoft.com/en-us/library/77c5xay2" target="_top">IndexOutOfRangeException</a></span> or a
                    <span sdata="cer" target="T:System.NullReferenceException"><a href="http://msdn2.microsoft.com/en-us/library/8w0s4024" target="_top">NullReferenceException</a></span> could happen when a subsequent call hits
                    upon a case that violates the class’ assumptions about its internal state).
                </p><p>
                    The minimal guarantee of any thread-safe collection is that this will not happen.
                </p><p>
                    As per writing to a 32-bit integer, if there are two or more simultaneous writes, then each thread will see the
                    value as having been written, and then an non-determinable thread will have the “final say”. For example:
                </p><ol><li><p>
                            If two threads enqueue values to a thread-safe queue, or push to a thread-safe then both will succeed but
                            the order in the collection is non-deterministic.
                        </p></li><li><p>
                            If two threads set the value for two different keys in a thread-safe dictionary, both succeed.
                        </p></li><li><p>
                            If two threads set the value for the same key, then both succeed, but the final value associated with the
                            key is non-determinable.
                        </p></li></ol><p>
                   Meanwhile, if an operation can be observed as beginning after another ended, the result is the same as if the two
                   were sequentially ordered on the same thread.
                </p><p>
                   A further guarantee with most operations (and with parts of the remaining operations, as described below) is that
                   all will either succeed or fail (should an operation either throw an exception or return a value indicating the
                   operation was rejected) as atomically and other threads will either see the state before or after the operation,
                   never observing a half-way state. In particular, should a thread be suspended or even aborted part-way through an
                   operation, then its operation will be observed as either not begun or completely fulfilled by any other threads.
                </p><p>
                   Many operations offer the second type of guarantee, of being able to reliably depend upon a current state. For
                   example, the <span sdata="cer" target="M:Ariadne.Collections.ThreadSafeDictionary`2.Update(`0,`1,`1)"><a href="Overload_Ariadne_Collections_ThreadSafeDictionary_2_Update.htm">Update</a></span>
                   overrides of the class behave similarly to
                   <span sdata="cer" target="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"><a href="http://msdn2.microsoft.com/en-us/library/4wx2c0dx" target="_top">Interlocked<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>CompareExchange</a></span>
                   in changing the current value assigned to a key if and only if it matches a comparand. Some overloads also reliably
                   return the previous value.
                </p><p>
                   (The third sort of synchronisation guarantee can be provided for any collection since it depends on external
                   locking, and while still useful in some cases, doesn’t require any support from the collection itself).
                </p><p>
                   Some methods or properties are not atomic. These are composed of multiple operations which are in themselves atomic
                   and which guarantee not to corrupt state as a whole. These are either:
                </p><ol><li><p>
                           Operations which report on the state of the collection as a whole. For example, some collections have an
                           O(n) <span sdata="cer" target="P:System.Collections.Generic.ICollection`1.Count"><a href="http://msdn2.microsoft.com/en-us/library/5s3kzhec" target="_top">Count</a></span>
                           property which walk the collections (generally where obtaining the count is deemed of little practical value but
                           supplied along-side an <span class="code">IsEmpty</span> property for completeness and for compatibility with the
                           <span sdata="cer" target="T:System.Collections.Generic.ICollection`1"><a href="http://msdn2.microsoft.com/en-us/library/92t2ye13" target="_top">ICollection<span class="languageSpecificText"><span class="cs">&lt;</span><span class="vb">(Of </span><span class="cpp">&lt;</span><span class="nu">(</span><span class="fs">&lt;'</span></span>T<span class="languageSpecificText"><span class="cs">&gt;</span><span class="vb">)</span><span class="cpp">&gt;</span><span class="nu">)</span><span class="fs">&gt;</span></span></a></span>
                           inteface). Some of the set operations are also not atomic (e.g.
                           <span sdata="cer" target="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"><a href="http://msdn2.microsoft.com/en-us/library/dd412074" target="_top">IsSubsetOf</a></span>).
                       </p></li><li><p>
                           Operations which perform multiple operations provided as a convenience or because greater performance can be offered by providing
                           a method which has access to internal state. For example the
                           <span sdata="cer" target="M:Ariadne.Collections.ThreadSafeDictionary`2.Remove(System.Func{`0,`1,System.Boolean})"><a href="M_Ariadne_Collections_ThreadSafeDictionary_2_Remove_3.htm">Remove</a></span>
                           overload that takes a predicate parameter is equivalent to calling the predicate for each item in the dictionary
                           and then removing the key if the predicate still holds.
                       </p></li><li><p>
                           Enumeration methods, as the state of the collection may obviously change while user code is processing the
                           enumeration.
                       </p></li><li><p>
                           In some cases, even when an atomic operation is possible, a non-atomic form may be more desirable. For
                           example, it is possible to dequeue all items in a queue or pop all items in a stack as an atomic operation.
                           In the case of a single consumer, this is preferable as it can then process the items removed more
                           efficiently since it need no longer contend even lock-lessly with other threads. In some cases with multiple
                           consumers, however, it may be preferable to have those multiple consumers contend with greater fairness
                           resulting. For this reason the
                           <span sdata="cer" target="M:Ariadne.Collections.LLQueue`1.DequeueAll"><a href="M_Ariadne_Collections_LLQueue_1_DequeueAll.htm">DequeueAll</a></span>
                           and <span sdata="cer" target="M:Ariadne.Collections.LLStack`1.PopAll"><a href="M_Ariadne_Collections_LLStack_1_PopAll.htm">PopAll</a></span>
                           methods have atomic equivalents;
                           <span sdata="cer" target="M:Ariadne.Collections.LLQueue`1.AtomicDequeueAll"><a href="M_Ariadne_Collections_LLQueue_1_AtomicDequeueAll.htm">AtomicDequeueAll</a></span>
                           and <span sdata="cer" target="M:Ariadne.Collections.LLStack`1.AtomicPopAll"><a href="M_Ariadne_Collections_LLStack_1_AtomicPopAll.htm">AtomicPopAll</a></span>
                           respectively.
                       </p></li></ol></div></div><div id="footer"><div class="footerLine"><img width="100%" height="3px" src="../icons/footer.gif" alt="Footer image" title="Footer image" /></div><A NAME="feedback"></A><span id="fb" class="feedbackcss"></span><p />Send comments on this topic to
        <a id="HT_MailLink" href="mailto:jon%40hackcraft.net?Subject=Ariadne">jon@hackcraft.net</a><script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        var HT_mailLinkText = HT_mailLink.innerHTML;
        HT_mailLink.href += ": " + document.title;
        HT_mailLink.innerHTML = HT_mailLinkText;
        </script><p /><a href="https://joinup.ec.europa.eu/software/page/eupl" target="_blank">© 2011-2012 Jon Hanna. Released under the European Union Public Licence v1.1</a></div></div></body></html>